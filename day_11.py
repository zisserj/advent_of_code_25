# -*- coding: utf-8 -*-
"""aoc_25_11.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1MWR6f1OT28YyPPVT-foTigb3CYaPAuS6
"""

import numpy as np
import scipy.sparse as sp

with open('input_11.txt') as f:
  content = f.read()

test = '''aaa: you hhh
you: bbb ccc
bbb: ddd eee
ccc: ddd eee fff
ddd: ggg
eee: out
fff: out
ggg: out
hhh: ccc fff iii
iii: out'''

def parse_input(text):
  graph = {}
  lines = text.split('\n')
  for l in lines:
    node, trans = l.split(':')
    graph[node] = trans.split()
  return graph

def graph_as_mat(g, map):
  mat = np.zeros((len(g)+1, len(g)+1), dtype=int)
  for n, out in g.items():
    for transition in out:
      mat[map[n], map[transition]] = 1
  return sp.csr_array(mat)

def count_paths(mat, map, start_node='you', end_node='out'):
  start_idx = map[start_node]
  end_idx = map[end_node]

  total_opts = mat[start_idx, end_idx]
  #print(0, total_opts)
  mat_iter = mat.copy()
  for steps in range(1, len(map)-2):
    mat_iter = mat_iter @ mat
    if mat_iter.sum() == 0:
      return(total_opts)
    cur_opts = mat_iter[start_idx, end_idx]
    #print(steps, cur_opts)
    total_opts += cur_opts
  return(total_opts)

graph = parse_input(content)
mapping = {v: i for i, v in enumerate(graph)}
mapping['out'] = len(graph)
reverse_mapping = {v: k for k, v in mapping.items()}
mat = graph_as_mat(graph, mapping)
count_paths(mat, mapping)

test2 = '''svr: aaa bbb
aaa: fft
fft: ccc
bbb: tty
tty: ccc
ccc: ddd eee
ddd: hub
hub: fff
eee: dac
dac: fff
fff: ggg hhh
ggg: fft out
hhh: out'''

graph = parse_input(content)
mapping = {v: i for i, v in enumerate(graph)}
mapping['out'] = len(graph)
reverse_mapping = {v: k for k, v in mapping.items()}

mat = graph_as_mat(graph, mapping)

mat_no_dac = mat.copy()
mat_no_dac[:, mapping['dac']] = 0

mat_no_fft = mat.copy()
mat_no_fft[:, mapping['fft']] = 0

# 'svr' -> 'dac' -> 'fft' -> 'out'
svr_to_dac = count_paths(mat_no_fft, mapping, start_node='svr', end_node='dac')
dac_to_fft = count_paths(mat, mapping, start_node='dac', end_node='fft')
fft_to_out = count_paths(mat, mapping, start_node='fft', end_node='out')


p1 = svr_to_dac*dac_to_fft*fft_to_out

# 'svr' -> 'fft' -> 'dac -> 'out'
svr_to_fft = count_paths(mat_no_dac, mapping, start_node='svr', end_node='fft')
fft_to_dac = count_paths(mat, mapping, start_node='fft', end_node='dac')
dac_to_out = count_paths(mat, mapping, start_node='dac', end_node='out')

p2 = svr_to_fft*fft_to_dac*dac_to_out

print(p1, p2)
print(p1+p2)